---
title : "자바 스터디 2회차 준비"
categories : 
    - java-study
tag :
    - java
toc : true
---

아래는 5월 30일 진행 할 스터디 준비 내용이다.  

- 2주차 목차
    - 배열
        - 배열이란?
        - 배열의 선언과 생성
        - 배열의 인덱스
        - 배열의 저장과 조회
        - 배열의 길이
    - String
        - equals
    - 2차원 배열
        - 2차원 배열의 선언과 생성
        - 2차원 배열의 인덱스
        - 2차원 배열의 저장과 조회
        - 2차원 배열의 길이
        - Arrays.sort()
    - 객체지향 프로그래밍 1
        - 객체지향 언어 (Object Oriented Programming)
        - 클래스의 구조
        - 필드, 생성자, 메서드
        - 메서드와 함수의 차이
        - 객체
        - 객체와 인스턴스



    - 1주차 과제
        - 객체지향 언어의 4가지 특징
            - 캡슐화
            - 추상화
            - 다형성
            - 상속
        - 객체지향 설계 원칙 5가지 (SOLID)
            - SRP : Single Responsibiliy Principal
            - OCP : Open Closed Principal
            - LSP : Liskov Substitution Principal
            - ISP : Interface Segregation Principal
            - DIP : Dependency Inversion Principal
            
---

### **1. 배열**  

#### **1-1) 배열이란?**
같은 타입의 여러 변수들을 하나의 묶음으로 만들어 사용하는 것을 배열 (Array) 라고 한다.  
더 큰 의미로는 자료의 조직, 관리, 저장을 의미하는 **자료구조** 중 하나이다.  

만약 10억개의 변수를 생성하고, 값을 부여해야 한다면, 10억번의 선언과 저장을 해야한다.  
배열을 잘 활용한다면 이런 노고는 반드시 줄어들 것이다.  

---

#### **1-2) 배열의 선언과 생성**
배열의 선언은 변수의 선언과 크게 다를 것 없다.  
선언할 배열의 타입, 배열의 이름, 그리고 배열임을 의미하는 대괄호를[] 사용한다.  

```text
타입[] 변수명;
타입 변수명[];
```

위 두 가지의 방법이 있다.  
다행스러운 것은 두 개의 방법에 차이는 없다.  

그저 C언어에서는 두 번째 방법으로 배열을 선언하는데,  
자바언어의 모체격인 C언어의 특징을 살려 둘 다 사용 할 수 있도록 구현한 것이다.  
일반적으로는 첫 번째 방법을 많이 사용하니 참고하자.  

```java
public static void main(String[] args) {
    
    int[] integerArr;
    String[] stringArr;

}
```

선언을 했으면 배열을 생성해야 한다.  
배열을 생성하기 위해선 new 연산자를 사용한다.  

```text
타입[] 변수명;
변수명 = new 타입[배열의 길이];
```

길이가 5인 int 배열을 생성해보자.  

```java
public static void main(String[] args) {
    int[] integerArr;
    integerArr = new int[5];
}
```

첫번째 줄은 그저 배열을 다룰 integerArr 변수를 생성한 것이고,  
두번째 줄에서 비로소 5개의 값을 저장할 수 있는 배열의 공간을 만든 것이다.  

위 두 줄의 코드를 줄여서 아래와 같이 표현 할 수 있다.  

```java
public static void main(String[] args) {
    int[] integerArr = new int[5];
}
```

위와 같은 배열 공간을 만들면, 배열은 타입의 기본값으로 채워진다.  
예를들어 int 배열이라면 0으로, boolean 배열이라면 false로,  
String 배열이라면 null로 초기화된다.  

---

#### **1-3) 배열의 인덱스**  
인덱스는 굉장히 중요한 요소이니 충분히 공부할 필요성이 있다.  
인덱스란 배열의 요소에 주어진 일련번호이다.  

먼저 배열의 구조를 그림으로 살펴보자.  
arr라는 이름의 배열이 있다고 가정하자.  

![error](/assets/images/java-study/2week/1-array.png)  

네모 4개를 합친 큰 네모는 arr 라는 배열 자체이다.  
그리고 각각의 배열 방이 있다.  
그 방 안에는 10, 50, 30, 5 라는 Element가 (요소) 있으며,  
각각의 배열방의 번호가 바로 index이다.  

다만 조금 헷갈릴 수 있는 것은 인덱스는 1부터 시작이 아닌, 0부터 시작이라는 것이다.  

쉽게 생각하자면 arr 호텔의 0번방에 묵는 10, 1번방에 묵는 50 .. 이라고 생각 하면 간단 할 수 있다.  

그렇기 때문에 배열의 요소에 정확히 접근하기 위해서는 인덱스를 알아야한다.  

---

#### **1-4) 배열의 저장과 조회**  
이제 인덱스를 알았으니, 배열에 값을 저장해본다.  
배열에 값을 저장하는 것 또한 변수에 값을 저장하는 것과 큰 차이가 없다.  

```java
public static void main(String[] args) {
    int[] arr = new int[4];

    arr[0] = 10;
    arr[1] = 50;
    arr[2] = 30;
    arr[3] = 5;
}
```

위 그림과 동일한 배열을 만들고, 값을 저장했다.  

또한 선언과 동시에 값을 저장할 수 도 있다.  

```java
public static void main(String[] args) {
    // 아래 방법은 가능하긴 하나, 불편하기 때문에 잘 쓰지 않는다.  
    // int[] arr = new int[] { 10, 50, 30, 5 };
    int[] arr = { 10, 50, 30, 5 };
}
```

이 경우엔 배열의 크기와 new 연산자를 굳이 작성하지 않아도 된다.  
다만 선언과 저장을 따로 할 경우엔 new 연산자를 생략하면 컴파일 에러가 발생하니 조심하자.  

```java
public static void main(String[] args) {
    // 이건 가능하다.
    int[] arr = { 10, 50, 30, 5 };

    // 이건 불가능하다.
    int[] arr2;
    arr2 = { 10, 50, 30, 5 };

    // 따로 하려면 아래와 같이 한다.
    int[] arr3;
    arr3 = new int[] { 10, 50, 30, 5 };
}
```

이러한 배열을 만들었으면, 사용을 해야 한다.  

```java
public static void main(String[] args) {
    int[] arr = { 10, 50, 30, 5 };
    System.out.println(arr);
}
```

이렇게 사용하면 될까?  
이 땐 **[I@704a52ec** 와 같은 타입@주소 형태의 배열의 참조변수가 출력된다.  
 
그렇다면 순회할 수 있는 몇 가지 방법을 알아보자.  

```java
public static void main(String[] args) {

    int[] arr = { 10, 50, 30, 5 };

    // 1번 방법 : index로 접근
    arr[3] = 100;               // arr[3]의 값을 100으로 수정
    System.out.println(arr[3]); // 100

    // 2번 방법 : for문으로 순회
    for (int i = 0; i < arr.length; i++) {
        arr[i] = i * 10;
        System.out.println(arr[i]);
    }

    // 3번 방법 : for-each문으로 순회
    // 지난 시간에 말했듯 for-each는 원본의 값을 수정하진 못한다.  
    for (int i : arr) {
		System.out.println(i);
    }

    // 4번 방법 Arrays 클래스의 toString 메서드를 사용한다. 이 경우 import는 필수이다. 
    System.out.println(Arrays.toString(arr));

}
```

---

#### **1-5) 배열의 길이**  
배열의 길이를 한번에 알아낼 수 있는 방법이 있다.  
바로 length 인데, 이 length는 조금 특이하다.  

일반적으로 이런 **기능**은 메서드가 수행하는데,  
length는 메서드가 아니며, 배열만의 고유한 필드(클래스 내부의 변수) 이다.  

공식 문서를 찾지 못해 정확하진 않지만,  
length는 final로 선언된 상수이며 (값을 변경하지 못하기 때문에),  

배열을 만들면서 크기를 지정해주면서, length의 값이 함께 지정되는 것으로 판단된다.  

사용하는 방법은 배열뒤에 . 연산자를 사용하고, length를 붙여준다.  
주의할 점은 0부터 카운트하는 인덱스와는 다르게 length는 순전히 배열의 크기라는 것 이다.  

```java
public static void main(String[] args) {
    int[] arr = { 5, 10, 30 };
    System.out.println(arr.length); 
    // 0번 인덱스, 1번 인덱스, 2번 인덱스 legnth는 2... 가 아니라 length는 3이다.
}
```

또 한 가지 중요한 점은 배열은 고정적인 크기를 가진 자료구조이다.  
크기를 벗어난 인덱스를 호출하면, ArrayIndexOutOfBoundsException 예외가 발생한다.  

```java
public static void main(String[] args) {
    int[] arr = { 5, 10, 30 };
    System.out.println(arr[100]); 
}

// Exception in thread "main" java.lang.  
// ArrayIndexOutOfBoundsException: Index 100 out of bounds for length 3
```

---

### **2. String**  
String 클래스는 상당히 내용이 많다.  
자세한 내용은 Chapter 9 에서 다시 다루도록 한다.  

#### **2-1) equals**  
지금까지 Primitive Type의 비교를 할 때 == 이라는 기호를 사용했다.  
Reference Type인 String은 == 을 사용했을때 정상적인 비교가 불가능하다.  

예시를 통해 이유를 알아보자.  

```java
public static void main(String[] args) {

    String a = "true가 나올까?";
    String b = "true가 나올까?";
    String c = a;
    
    System.out.println("a == b ? " + a == b);
    System.out.println("a == c ? " + a == c);
    System.out.println("b == c ? " + b == c);

    System.out.println("a.equals(b) ? " + a.equals(b));
    System.out.println("a.equals(c) ? " + a.equals(c));
    System.out.println("b.equals(c) ? " + b.equals(c));
    
}
```

a와 b 그리고 c는 결과적으로 값이 동일하다.  
그러나, 가지고 있는 주소값은 각자 다르다.  

== 연산자를 통해 비교했을때 모두 false가 나온 이유는 == 연산자는 주소값을 비교하기 때문이다.  
반면 equals 메서드는 실제 값을 비교한다.  
그렇기 때문에 equals 메서드를 통해 비교했을 땐 모두 true가 나오는 것이다.  


그렇다면, a와 b는 그렇다 쳐도, c는 a를 복사해 만든 것이니 주소가 같아야 하지 않을까?  
결론부터 말하자면 그렇지 않다.  
이는 String의 특성 때문인데, String은 값을 변경할 때 무조건 새로운 주소값에 저장한다.  

더 깊은 내용은 Chapter 9 에서 공부하도록 한다.  

---

### **3. 2차원 배열**  
앞서 공부한 배열은 1차원 배열이다.  
지금 공부할 2차원 배열은 테이블 형태의 데이터를 담는데 사용된다.  

대부분의 내용은 1차원 배열과 동일하지만, 2차원 배열을 잘 이해해야 그 이상의 다차원 배열을 쉽게 이해할 수 있다.  

#### **3-1) 2차원 배열의 선언과 생성**  
2차원 배열의 선언은 1차원 배열과 거의 동일하다.  
기존 대괄호에, 대괄호를 하나 더 붙인 것 뿐이다.  

```java
int[][] arr;

int arr[][];

int[] arr[];
```

가장 위의 방법을 제일 많이 사용하니 참고하자.  

다음은 배열을 생성한다.  

```java
int[][] arr = new int[4][3];    // 4행 3열의 배열이다.
```

![error](/assets/images/java-study/2week/2-2D_array.png)  

위와 같은 테이블 형태로 배열방이 생성된다.  
두 개의 대괄호 중 왼쪽은 가로, 오른쪽은 세로의 크기이다.  
가로 한 줄은 하나의 배열이다.  

다시말해 2차원 배열은 1차원 배열들의 배열인 셈이다.  

---

#### **3-2) 2차원 배열의 인덱스**  
2차원 배열 마찬가지로 요소에 접근하기 위해선 인덱스를 통해야 한다.  

```java
public static void main(String[] args) {
    
    int[][] arr = new int[4][3];
    arr[0][0] = 100;
    arr[1][3] = 300;

}
```

---

#### **3-3) 2차원 배열의 저장과 조회**  
다음은 2차원 배열을 저장하는 방법이다.  

```java
public static void main(String[] args) {
    
    // 1차원 배열과 마찬가지로 선언과 저장을 동시에 할 경우 new 연산자는 생략 가능하다.  
    // int[][] arr = new int[][] { { 1, 2, 3 }, { 4, 5, 6 } };

    int[][] arr = {
        { 1, 2, 3 },
        { 4, 5, 6 }
    };

}
```

다음은 2차원 배열을 조회하는 몇 가지 방법이다.  

```java
public static void main(String[] args) {

    int[][] arr = {
        { 1, 2, 3 },
        { 4, 5, 6 }
    };

    System.out.println("인덱스로 조회");
    System.out.print(arr[0][0] + " ");
    System.out.println(arr[1][2] + "\n");
    
    System.out.println("for문으로 조회");
    for (int i = 0; i < arr.length; i++) {
        for (int j = 0; j < arr[i].length; j++) {
            System.out.print(arr[i][j] + " ");
        }
        System.out.println();
    }
    
    System.out.println();
		
    System.out.println("for-each문으로 조회");
    for (int[] i : arr) {
        for (int j : i) {
            System.out.print(j + " ");
        }
        System.out.println();
    }
    
    System.out.println();    

    System.out.println("Arrays.deepToString() 메서드로 조회");
    System.out.println(Arrays.deepToString(arr));

}

인덱스로 조회
1 6

for문으로 조회
1 2 3 
4 5 6 

for-each문으로 조회
1 2 3 
4 5 6 

Arrays.deepToString() 메서드로 조회
[[1, 2, 3], [4, 5, 6]]
```

1차원 배열과 비슷하게 Arrays 클래스에는 deepToString 메서드를 사용할 수 있다.  

for문과 for-each문은 2중 for문을 사용해야 한다.  

---

#### **3-4) 2차원 배열의 길이**  
2차원 배열의 길이도 마찬가지로 length를 통해 알 수 있다.  
그러나 조금 다른 점이 있다.  

```java
public static void main(String[] args) {
    int[][] arr = {
            { 1, 2, 3 },
            { 4, 5 }
        };

    System.out.println("arr 전체 길이 : " + arr.length);
    System.out.println("arr[0] 길이 : " + arr[0].length);
    System.out.println("arr[1] 길이 : " + arr[1].length);
}

arr 전체 길이 : 2
arr[0] 길이 : 3
arr[1] 길이 : 2
```

2차원 배열의 length를 출력해보면 전체의 길이가 나오는데,  
이때 기준은 세로의 개수이다.  

즉 2차원 배열은 1차원 배열들의 배열이기 때문이다.  
그렇기 때문에 각자의 배열 길이를 확인할 수 있다.  

---

#### **3-5) Arrays.sort()**  
Arrays 클래스에는 다양한 메서드가 있다.  
이 중 sort를 알아보자.  
sort는 정렬이다.  
종류는 Selection Sort, Bubble Sort, Insertion Sort, Quick Sort, Merge Sort 등등 굉장히 많다.  
이런 알고리즘 중 Arrays.sort() 메서드는 Insertion Sort, Dual Pivot Quick Sort, Count Sort, Merge Sort, Tim Sort를 상황에 맞게 더욱 효과적인 사용한다...  

1차원 배열의 정렬이다.  

```java
public static void main(String[] args) {
    int[] arr = { 100, 20, 32 };

    
    System.out.println("Sort 전");
    System.out.println(Arrays.toString(arr) + "\n");

    Arrays.sort(arr);
    
    System.out.println("Sort 후");
    System.out.println(Arrays.toString(arr));
}

Sort 전
[100, 20, 32]

Sort 후
[20, 32, 100]
```

아래는 2차원 배열의 정렬이다.  
2차원 배열의 정렬은 종류가 많아, 각 배열의 0번 원소값을 비교해 정렬하는 코드만 첨부했다.  

```java
public static void main(String[] args) {
    int[][] arr = {
            { 100, 20, 32 },
            { 40, 54 }
        };

    
    System.out.println("Sort 전");
    System.out.println(Arrays.deepToString(arr) + "\n");

    Arrays.sort(arr, Comparator.comparingInt(e -> e[0]));
    
    System.out.println("Sort 후");
    System.out.println(Arrays.deepToString(arr));
}

Sort 전
[[100, 20, 32], [40, 54]]

Sort 후
[[40, 54], [100, 20, 32]]
```

---

### **4. 객체지향 프로그래밍1**   

#### **4-1) 객체지향 언어 (Object Oriented Programming)**  
객체지향의 개념은 다양한 프로그래밍 패러다임 중 하나로,    
객체 간의 상호작용을 통해 프로그램을 개발하는 방법이다.  

객체지향언어의 특징은 다음과 같다.  

1. 코드의 재사용성이 높다.  
2. 코드의 관리가 용이하다.  
3. 신뢰성이 높은 프로그래밍을 할 수 있다.  

---

#### **4-2) 클래스의 구조**  
클래스의 구조를 익혀보자.  

![error](/assets/images/java-study/2week/3-class.png)  
클래스는 크게 필드와, 생성자, 그리고 메서드로 이루어져있다.  

자바는 변수를 지칭하는 용어가 꽤 많다.  
필드(Field), 전역변수(Global Variable), 지역변수 (Local Variable) ...  

지역변수는 메서드, for문, if문 등에 정의된 변수를 의미한다.  

필드는 클래스에 정의 된 변수를 의미한다.  
멤버변수 혹은 전역변수라고 부르며, "객체의 속성"을 나타낸다.    
그리고 자체적으로 값을 지정하기 보단 대부분의 경우 외부에서 값을 지정하게 된다.  

이때 객체를 생성함과 동시에 값을 지정할 수 있도록 해주는 역할을 생성자가 하며,  

메서드는 "객체의 기능"을 나타낸다.  

---

#### **4-3) 필드, 생성자, 메서드**  

간단한 예시를 보자.  

```java
public class Person {
    
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    private String name;
    private int age;

    public String toString() {
        return "Person{" +
                "신규회원 이름 = " + name +
                ", 신규회원 나이 = '" + age + '\'' +
                '}';
    }
}

public class Main {
    public static void main(String[] args) {
        Person constructor = new Person("LEE GI CHEOL", 26);
        System.out.println(constuctor.toString());
    }
}
```

클래스 맨위의 클래스와 동명의 메서드 같은 것이 있다.  
이게 바로 생성자이다.  
클래스와 동일한 접근제어자, 반환값은 항상 void이기 때문에 작성하지 않고,  
생성과 동시에 저장할 변수의 값을 인자로 받는다.  

자바는 기본적으로 클래스 당 생성자는 무조건 한개가 필요한데,  
아무런 생성자를 작성하지 않았을 때 컴파일러가 아무런 인자도 없는 기본 생성자를 만들어준다.  

잠시 1회차 스터디 자료를 다시 보도록 하자.  

![error](/assets/images/java-study/1week/3-compile-step1.png)  

![error](/assets/images/java-study/1week/7-compile-step4.png)  

분명 main 메서드와 print 메서드만 있는 클래스인데, 바이트코드엔 생성자가 포함되어있다.  

다음은 필드이다. 위 예제에 name, age 변수는 메서드안에 속한 변수가 아니라,  
클래스안에 속한 전역변수이다.  
이러한 변수들을 멤버변수 혹은 필드라 부른다.  

메서드는 다음 예제를 보도록 한다.  

```java
public class Person {
    public Person() {}

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    private String name;
    private int age;
    private static Map<String, String> map = new HashMap<>();

    public String getName() {
        return name;
    }

    public void setName() {
        this.name = name;
    }

    public int getAge() {
        return age; 
    }

    public void setAge(int age) {
        this.age = age;
    }

    public void save(String key, Person person) {
        map.put(key, person.toString());
    }

    public void printUser() {
        Set<String> key = map.keySet();

        for (String s : key) {
            System.out.println("회원 목록 : " + map.get(s));
        }
    }

    public String toString() {
        return "Person{" +
				"신규회원 이름 = " + name +
				", 신규회원 나이 = '" + age + '\'' +
				'}';
    }
}

public class SignUpUser {

    public static void main(String[] args) {
        Person signUpPerson = new Person();
        signUpPerson.setName("LEE GI CHEOL");
        signUpPerson.setAge(26);
        
        signUpPerson.save("LEEGICHEOL", signUpPerson);

        signUpPerson.setName("EKKKK1");
        signUpPerson.setAge(20);
        
        signUpPerson.save("EKKKK1", signUpPerson);
        
        signUpPerson.printUser();
    }

}
```

Person 클래스를 선언하기 위해선 new 연산자를 사용한다.  
이때 이 단계에서 참조변수 signUpPerson에 객체의 주소가 저장이 되며, 객체가 생성된다.  

클래스와 객체가 있기 때문에 이름과 나이를 메서드를 통해 지정하고,  
save, printUser 메서드를 통해 저장/출력을 할 수 있다.  
이것이 바로 코드의 재사용성이다.  

지금은 간단한 코드라 와닿지 않겠지만,  
만약 save 메서드가 정말 회원가입 메서드라면,  
DB Connection과 같은 많은 코드가 있을 것이다.  
과장해서 100줄이 넘는 코드라고 상상을 해보자.  

저장할때마다 100줄 이상의 코드를 작성한다는 것은  
너무나도 귀찮을뿐더러 유지보수성이 너무나도 떨어진다.  

근데 메서드를 사용하면 단 한줄로 100줄의 코드를 호출할 수 있고,  
이름만 잘 지어준다면, 코드를 자세히 읽지 않아도 대략적으로 무엇을 하는지 알 수 있다.  

그렇기 때문에 메서드는 "객체의 기능" 을 나타낸다고 할 수 있다.  

---

#### **4-4) 메서드와 함수의 차이**  
메서드와 함수는 보통 혼용해서 사용하는 경우가 많다.  
실제로 메서드와 함수는 동일하다.  
다만 함수는 클래스 안, 밖 어디든 선언 가능하지만, 메서드는 무조건 클래스 안에 선언되어 있어야 한다.  

역할 자체는 같기 때문에 헷갈릴 수 있고, 그 때문에 혼용을 하는데  
완전히 같은 개념이 아니라는 것을 알아두자.  

---

#### **4-5) 객체**  
자 그렇다면 객체란 무엇일까.  
자바는 클래스에 변수, 메서드 등을 작성을 하면서 개발을 한다.  
이 클래스는 쉽게 말하자면 설계도 정도라고 볼 수 있다.  

객체는 이러한 클래스로부터 생성된 것을 말하며,   
설계도를 통해 생성된 일종의 제품이다.  

---

#### **4-6) 객체와 인스턴스**
객체는 클래스가 선언 되어 있을 때 객체라 부르며,  
인스턴스는 그 객체가 메모리에 할당되어 사용될 때를 말한다.  

객체가 인스턴스를 포함한 더 큰 개념이다.  

사실 상 둘은 같은 의미이기 때문에 혼용해서 사용하는 경우가 대다수이다.  

---

#### **4-7) 한 파일에 여러 클래스 작성하기**

```java
public class ManyClass {
    
}

class SomeThing {

}
```

한 파일 (java파일)에 여러 클래스를 작성한다면 단순히 이렇게 사용하면 된다.  

다만 주의 할 점은 파일명과 동일한 클래스는 항상 public 이거나, default (SomeThing 클래스처럼 아무것도 작성되지 않는 경우) 여야 한다.  
SomeThing 클래스는 항상 default 여야 한다.  

![error](/assets/images/java-study/2week/4-many-class.png)  


![error](/assets/images/java-study/2week/5-many-class.png)  

이렇게 만들어도 컴파일 시 ManyClass와, SomeThing은 분리되어 class파일이 생성된다.  

ManyClass 안에 Class를 만들 수 있지만, 지금은 우선 여기까지만 공부하도록 한다.  

참고사항으로 위의 경우 ManyClass.class파일과, ManyClass$SomeThing.class 파일이 생성된다.  

---

#### **4-7) 객체의 생성과 사용**
객체를 생성할 때는 new 라는 연산자를 사용한다.  
여기서 new는 단순히 객체를 생성한다기보단 굉장히 많은 역할을 한다.  

우선 new 연산자를 사용해서 만들어진 객체는 Reference Type이다.  

Reference Type은 무엇일까?  

자바는 메모리 영역이 크게 3가지가 있다.  
static, stack, heap  
static은 필드, static 키워드가 붙은 변수 등을 저장한다.  
프로그램이 시작되고, 종료될때까지 이 영역에 저장되어 사용된다.  
그렇기에 전역변수를 어디에서나 사용할 수 있는 것이다.  
또한 그렇기에 static 영역에 메모리를 지나치게 많이 사용한다면, 프로그램에 굉장히 부담스러운 일이 될 것이므로 주의해서 사용하도록 한다.  

stack은 지역변수가 저장되는 공간이다.  
이 영역엔 하나의 if문, for문, method가 실행될 때 저장되고, 종료될때 제거된다.  
자료구조의 stack으로 구성되어 있으며, 지역변수가 다른 곳에서 사용되지 못하는 이유이다.  

heap은 바로 이 new 연산자를 통해 생성된 Reference Type이 저장되는 곳이다.  
대부분의 변수, 메서드가 사용되는 곳은 stack 영역인데, heap 영역에 저장된 데이터의 참조값을 stack 영역에서 리턴받아 사용하는 방식으로 이루어진다.  

```java
public class HeapTest {
    public static void main(String[] args) {
        String hello = "HelloWorld";
    }
}
``` 

이러한 String 타입 변수가 있다면, HelloWorld라는 값은 Heap영역에 저장되고, 이 값을 hello라는 변수를 통해 리턴받아 아래와 같이 사용하는 것이다.  

![error](/assets/images/java-study/2week/6-stack-heap.png)  


만약 heap 영역의 데이터가 더 이상 필요없어지는 시기가 온다면, Garbage Collector에 의해 메모리가 해제된다.  

---



---

작성중 

**1. 1주차 과제**  

**1-1) 객체지향 언어의 4가지 특징**  

**1-1-1) 캡슐화**  
캡슐화는 연관성있는 변수와 메서드를 클래스로 묶는 작업을 의미한다.  
캡슐화를 함으로써 얻는 이점은 **은닉성**이다.  
중요한 데이터를 외부에서 쉽게 접근/변경하지 못하도록 할 수 있다.  

접근제어자를 통해 변수 혹은 메서드를 은닉하거나 접근할 수 있다.  

예를들어 아래와 같은 코드가 있다.  

```java
public class Person {

    private int age;
    private String name;
    private String phoneNumber;

}
```

위 3개의 변수는 private 접근제어자를 사용하여 Person 클래스에서만 사용할 수 있도록 은닉한다.  
접근/변경할 때는 어떻게 하는지 확인해보자.  

```java
public class Person {

    private int age;
    private String name;
    private String phoneNumber;


    public int getAge() {
		return age;
	}

	public void setAge(int age) {
		this.age = age;
	}
	
    public String getName() {
		return name;
	}
	
    public void setName(String name) {
		this.name = name;
	}
	
    public String getPhoneNumber() {
		return phoneNumber;
	}
	
    public void setPhoneNumber(String phoneNumber) {
		this.phoneNumber = phoneNumber;
	}

}
```

변수는 private으로 선언되어있어 다른 클래스에서 사용하지 못한다.  
그러나 위 메서드들은 public으로 선언되어있어 다른 클래스에서도 사용할 수 있다.  
이러한 메서드들을 Getter, Setter 라고 부른다.  

그럼 어차피 메서드를 통해 사용할 수 있는데 과연 이게 무슨 소용일지 궁금할 수 있을텐데,  
여기서 중요한 것은 Person 클래스의 변수를 접근/변경을 하기 위해선 꼭 Person 클래스가 필요하다.  
아무리 Getter Setter가 public이라해도, Person 클래스가 없다면 사용 불가하다.  




- 객체지향 언어의 4가지 특징
- 캡슐화
- 추상화
- 다형성
- 상속
- 객체지향 설계 원칙 5가지 (SOLID)
- SRP : Single Responsibiliy Principal
- OCP : Open Closed Principal
- LSP : Liskov Substitution Principal
- ISP : Interface Segregation Principal
- DIP : Dependency Inversion Principal